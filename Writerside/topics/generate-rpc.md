# 生成协议接口

框架提供了协议结构自动生成工具,我们在日常开发中, 可以使用该工具,根据自定义的接口生成对应的.go结构文件和.cs的类文件(unity)


参考以下文档
: [客户端协议](api-standard.md)
: [服务器协议](rpc-standard.md)

## 客户端协议
客户端发送协议到服务器所需api

!!!!!注意!!!!!
: 对于服务器来说,我们并不一定需要定义api接口
: 这里的协议结构代码生成主要用于两个方面
: 1.结合robot包下的客户端,实现robot自动化测试.
: 2.生成CS文件,方便客户端使用
: 如果没有以上两项需求,可以不需要生成api结构化文件
: 但是还是建议大家定义相关的逻辑节点协议接口.

### 代码示例

#### 逻辑节点协议接口

```Go
type IUserService interface {
	LoadUserDataInfo(ctx context.Context, args *rpc.Args[*pb.LoadUserInfoReq], reply *rpc.Reply[*pb.LoadUserDataInfo]) (err error)
}

type ILoginService interface {
	Login(ctx context.Context, args *rpc.Args[*pb.LoginReq], reply *rpc.Reply[*pb.LoginRes]) (err error)
}
```

在kit/cmd目录下,创建我们的api协议启动类. 使用以下代码自动生成对应的api接口
#### 生成代码
```Go
func main() {
    //设置导出的golang目录
	util.SetAutoGenerateAPICodePath("../common/api")
	//设置导出的C#目录(用于Unity项目)
	util.SetAutoGenerateAPICSCode("E:\\unity\\project\\t2\\Assets\\HotFix\\Code", "HotFix.Code")
	//根据接口生成对应的api结构
	util.GeneratorAPI[service.ILoginService](login.ModuleName, login.Version, "api")
	util.GeneratorAPI[service.IUserService](user.ModuleName, user.Version, "api",
		"UserLevelPush")
	//生成Cs代码(用于Unity)
	util.GenerateCSApiService()
}
```

#### 结果代码 {id="generate-rpc-client-resource"}

生成的`IUserService`代码范例
```Go
//Auto generated by tgf util
//created at 2023-12-05 17:19:56.1347906 +0800 CST m=+0.080327701

package api

import (
	"github.com/thkhxm/tgf/rpc"

	"github.com/thkhxm/tgf/xgame/common/pb"
)

var userService = &rpc.Module{Name: "user", Version: "1.0"}

var (
	LoadUserDataInfo = rpc.ServiceAPI[*pb.LoadUserInfoReq, *pb.LoadUserDataInfo]{
		ModuleName:  userService.Name,
		Name:        "LoadUserDataInfo",
		MessageType: userService.Name + "." + "LoadUserDataInfo",
	}
)

const (
	UserLevelPush = "UserLevelPush"
)

```
### 代码讲解
这里主要关注这段代码`util.GeneratorAPI[service.ILoginService](login.ModuleName, login.Version, "api")`

`[service.ILoginService]` 这里指定了我们需要生成的协议接口

`login.ModuleName, login.Version` 这里指的是我们提供服务的节点名称,详情可以查看[逻辑节点](service-stand.md)

`api` 生成的结构包名

在我们生成的结构中  

`LoadUserDataInfo` 请求协议

`UserLevelPush = "UserLevelPush"` 主动推送协议

> 这里我们建议将所有api生成在同一包目录下,最终得到的目录结构如下
#### 目录结构
![generaterpcdir.png](generaterpcdir.png)


> x_api 为自动生成的结构文件,x_service为我们自定义的接口

## 服务器协议

服务器之间的rpc请求

### 代码示例

#### rpc协议接口
```Go
type IUserRPCService interface {
	GetUserData(ctx context.Context, args *usermodels.LoadLoginUserRequest, reply *usermodels.LoadLoginUserResponse) (err error)
	RegisterUser(ctx context.Context, args *usermodels.RegisterUserRequest, reply *rpc.EmptyReply) (err error)
}
```

在kit/cmd目录下,创建我们的rpc协议启动类. 使用以下代码自动生成对应的rpc接口
#### 生成代码
```Go
func main() {
    //设置导出的golang目录
	util.SetAutoGenerateAPICodePath("../common/api")
	//设置生成的文件后缀
	util.SetGenerateFileNameSuffix("rpc")
	//根据接口生成对应的rpc结构
	util.GeneratorRPC[service.IUserRPCService](user.ModuleName, user.Version, "userservice", "user")
}
```
#### 结果代码
生成的`IUserRPCService`代码范例

```Go
//Auto generated by tgf util
//created at 2023-12-05 18:27:36.4589565 +0800 CST m=+0.038280801

package userservice

import (
	"github.com/thkhxm/tgf/rpc"

	"github.com/thkhxm/tgf/xgame/common/rpc/model/user"
)

var userService = &rpc.Module{Name: "user", Version: "1.0"}

var (
	GetUserData = rpc.ServiceAPI[*usermodels.LoadLoginUserRequest, *usermodels.LoadLoginUserResponse]{
		ModuleName:  userService.Name,
		Name:        "GetUserData",
		MessageType: userService.Name + "." + "GetUserData",
	}

	RegisterUser = rpc.ServiceAPI[*usermodels.RegisterUserRequest, *rpc.EmptyReply]{
		ModuleName:  userService.Name,
		Name:        "RegisterUser",
		MessageType: userService.Name + "." + "RegisterUser",
	}

)

```

### 代码讲解

核心代码
: `util.GeneratorRPC[service.IUserRPCService](user.ModuleName, user.Version, "userservice", "user")`

`[service.IUserRPCService]` 这里指定了我们需要生成的RPC协议接口
`user.ModuleName, user.Version` 这里指的是我们提供服务的节点名称,详情可以查看[逻辑节点](service-stand.md)
`"userservice"` 生成的结构包名
`"user"` 代码生成的目录,最终目录为`"../common/api/user"`,处理不同rpc服务使用不同的目录存放

> 我们建议每一个不同的逻辑节点,都为他们生成一个单独的目录,这样在进行rpc调用的时候,可以使用不同的包名,进行引用
> 具体使用可以参考文档 [服务器RPC请求](rpc-request.md)

#### 目录结构

![generaterpc.png](generaterpc.png)